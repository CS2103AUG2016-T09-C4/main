# A0143095H
###### \java\seedu\unburden\logic\commands\DoneCommand.java
``` java
 */

//@@Gauri Joshi A0143095H
public class DoneCommand extends Command {

    public static final String COMMAND_WORD = "done";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing as done.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Well done! Task Done!";

    public final int targetIndex;

    public DoneCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDone = lastShownList.get(targetIndex - 1);

        model.saveToPrevLists();
        model.doneTask(taskToDone, true);

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDone));
    }

}
```
###### \java\seedu\unburden\logic\commands\UnDoneCommand.java
``` java
 */
public class UnDoneCommand extends Command {

    public static final String COMMAND_WORD = "undone";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing as undone.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Task Marked as Undone";

    public final int targetIndex;

    public UnDoneCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }


    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDone = lastShownList.get(targetIndex - 1);

        model.saveToPrevLists();
        model.doneTask(taskToDone, false);

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDone));
    }

}
```
###### \java\seedu\unburden\logic\parser\Parser.java
``` java
	private static final Pattern KEYWORDS_DATE_FORMAT = Pattern.compile("(?<dates>[0-9]{2}[-][0-9]{2}[-][0-9]{4}$)");

	// Event
	private static final Pattern ADD_FORMAT_0 = Pattern.compile("(?<name>[^/]+)"
			+ "(?<isTaskDescriptionPrivate>p?)i/(?<taskDescriptions>[^/]+)" + "(?<isDatePrivate>p?)d/(?<date>[^/]+)"
			+ "(?<isStartTimeArgumentsPrivate>p?)s/(?<startTimeArguments>[^/]+)"
			+ "(?<isEndTimeArgumentsPrivate>p?)e/(?<endTimeArguments>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Event without task description
	private static final Pattern ADD_FORMAT_1 = Pattern.compile("(?<name>[^/]+)"
			+ "(?<isDatePrivate>p?)d/(?<date>[^/]+)"
			+ "(?<isStartTimeArgumentsPrivate>p?)s/(?<startTimeArguments>[^/]+)"
			+ "(?<isEndTimeArgumentsPrivate>p?)e/(?<endTimeArguments>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Deadline
	private static final Pattern ADD_FORMAT_2 = Pattern.compile("(?<name>[^/]+)"
			+ "(?<isTaskDescriptionPrivate>p?)i/(?<taskDescriptions>[^/]+)" + "(?<isDatePrivate>p?)d/(?<date>[^/]+)"
			+ "(?<isEndTimeArgumentsPrivate>p?)e/(?<endTimeArguments>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Deadline without task description
	private static final Pattern ADD_FORMAT_3 = Pattern.compile("(?<name>[^/]+)"
			+ "(?<isDatePrivate>p?)d/(?<date>[^/]+)" + "(?<isEndTimeArgumentsPrivate>p?)e/(?<endTimeArguments>[^/]+)"
			+ "(?<tagArguments>(?: t/[^/]+)*)");

	// Deadline without task description and time
	private static final Pattern ADD_FORMAT_4 = Pattern
			.compile("(?<name>[^/]+)" + "(?<isDatePrivate>p?)d/(?<date>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Deadline without task description and date
	private static final Pattern ADD_FORMAT_5 = Pattern.compile("(?<name>[^/]+)"
			+ "(?<isEndTimeArgumentsPrivate>p?)e/(?<endTimeArguments>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Deadline without date
	private static final Pattern ADD_FORMAT_6 = Pattern.compile("(?<name>[^/]+)"
			+ "(?<isTaskDescriptionPrivate>p?)i/(?<taskDescriptions>[^/]+)"
			+ "(?<isEndTimeArgumentsPrivate>p?)e/(?<endTimeArguments>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Deadline without time
	private static final Pattern ADD_FORMAT_7 = Pattern
			.compile("(?<name>[^/]+)" + "(?<isTaskDescriptionPrivate>p?)i/(?<taskDescriptions>[^/]+)"
					+ "(?<isDatePrivate>p?)d/(?<date>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Floating task
	private static final Pattern ADD_FORMAT_8 = Pattern.compile("(?<name>[^/]+)"
			+ "(?<isTaskDescriptionPrivate>p?)i/(?<taskDescriptions>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	// Floating task without task description
	private static final Pattern ADD_FORMAT_9 = Pattern.compile("(?<name>[^/]+)" + "(?<tagArguments>(?: t/[^/]+)*)");

	private static final Pattern EDIT_FORMAT = Pattern.compile("(?<index>[^/]+)(?!$)" + "((?<name>[^/]+))?" + "(i/(?<taskDescriptions>[^/]+))?"
			+ "(d/(?<date>[^/]+))?" + "(s/(?<startTimeArguments>[^/]+))?" + "(e/(?<endTimeArguments>[^/]+))?");
	
	private static final Pattern SET_DIR_FORMAT = Pattern.compile("(?<filename>.+).xml");
	
	private static final Pattern SET_DIR_FORMAT_RESET = Pattern.compile(SetDirectoryCommand.COMMAND_RESET);

	private static final String byToday = "by today";

	private static final String byTomorrow = "by tomorrow";

	private static final String byNextWeek = "by next week";

	private static final String byNextMonth = "by next month";

	private static final String today = "today";

	private static final String tomorrow = "tomorrow";

	private static final String nextWeek = "next week";
	
	private static final String done = "done";
	
	private static final String undone = "undone";

	private static final DateFormat dateFormatter = new SimpleDateFormat("dd-MM-yyyy");

	public Parser() {
	}

	/**
	 * Parses user input into command for execution.
	 *
	 * @param userInput
	 *            full user input string
	 * @return the command based on the user input
	 * @throws ParseException
	 */
	
```
###### \java\seedu\unburden\logic\parser\Parser.java
``` java
	 */
	//@@Gauri Joshi A0143095H
	private Command prepareDone(String args) {
		Optional<Integer> index = parseIndex(args);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
		}

		return new DoneCommand(index.get());
	}
	
	//@@Nathanael Chan A0139678J

	/**
	 * Sets up undone command to be executed
	 * 
	 * @param args
	 *            full command args string
	 * @return prepared undoneCommand
	 * 
```
###### \java\seedu\unburden\logic\parser\Parser.java
``` java
	 */
	private Command prepareUnDone(String args) {
		Optional<Integer> index = parseIndex(args);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SelectCommand.MESSAGE_USAGE));
		}

		return new UnDoneCommand(index.get());
	}
	
	

	private Command prepareHelp(String args) {
		args = args.trim();

		switch (args.toLowerCase()) {
		case AddCommand.COMMAND_WORD:
			return new HelpCommand(AddCommand.COMMAND_WORD);
		case DeleteCommand.COMMAND_WORD:
			return new HelpCommand(DeleteCommand.COMMAND_WORD);
		case FindCommand.COMMAND_WORD:
			return new HelpCommand(FindCommand.COMMAND_WORD);
		case EditCommand.COMMAND_WORD:
			return new HelpCommand(EditCommand.COMMAND_WORD);
		case ClearCommand.COMMAND_WORD:
			return new HelpCommand(ClearCommand.COMMAND_WORD);
		case ListCommand.COMMAND_WORD:
			return new HelpCommand(ListCommand.COMMAND_WORD);
		case "":
			return new HelpCommand(HelpCommand.COMMAND_WORD);
		case ExitCommand.COMMAND_WORD:
			return new HelpCommand(ExitCommand.COMMAND_WORD);
		default:
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
		}
	}
}
```
###### \java\seedu\unburden\model\ListOfTask.java
``` java
    public void doneTask(ReadOnlyTask key, boolean isDone){
    	tasks.done(key,isDone);
    }
    //@@Gauri Joshi
    
```
###### \java\seedu\unburden\model\ListOfTask.java
``` java
    public void undoneTask(ReadOnlyTask key, boolean isDone){
    	tasks.done(key,isDone);
    }
    
//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        tags.add(t);
    }

//// util methods

    @Override
    public String toString() {
        return tasks.getInternalList().size() + " Tasks, " + tags.getInternalList().size() +  " tags";
        // TODO: refine later
    }

    @Override
    public List<ReadOnlyTask> getTaskList() {
        return Collections.unmodifiableList(tasks.getInternalList());
    }

    @Override
    public List<Tag> getTagList() {
        return Collections.unmodifiableList(tags.getInternalList());
    }

    @Override
    public UniqueTaskList getUniqueTaskList() {
        return this.tasks;
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tags;
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ListOfTask // instanceof handles nulls
                && this.tasks.equals(((ListOfTask) other).tasks)
                && this.tags.equals(((ListOfTask) other).tags));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasks, tags);
    }
}
```
###### \java\seedu\unburden\model\Model.java
``` java
	/** Marks a task as done when it is completed. */
	void doneTask(ReadOnlyTask taskToDone, boolean isDone);
	
	/** Marks a task as undone when it is not completed. */
	void undoneTask(ReadOnlyTask taskToDone, boolean isUnDone);

}
```
###### \java\seedu\unburden\model\ModelManager.java
``` java
    @Override 
    public synchronized void doneTask(ReadOnlyTask taskToDone, boolean isDone){
    	listOfTask.doneTask(taskToDone,isDone);
    	updateFilteredListToShowAll();
    	indicateTaskListChanged();
    }
    
```
###### \java\seedu\unburden\model\ModelManager.java
``` java
    @Override 
    public synchronized void undoneTask(ReadOnlyTask taskToDone, boolean isunDone){
    	listOfTask.doneTask(taskToDone,isunDone);
    	updateFilteredListToShowAll();
    	indicateTaskListChanged();
    }
    
```
###### \java\seedu\unburden\model\task\Date.java
``` java
 */

```
###### \java\seedu\unburden\model\task\Date.java
``` java
public class Date {

    public static final String MESSAGE_DATE_CONSTRAINTS = "Task dates should be in the format dd-mm-yyyy";
    public static final String DATE_VALIDATION_REGEX = "[0-9]{2}[-][0-9]{2}[-][0-9]{4}$";
    
   

    public final String fullDate;

    /**
     * Validates given date.
     *
     * @throws IllegalValueException if given date string is invalid.
     */
    public Date(String date) throws IllegalValueException {
        /*assert date != null;
        date = date.trim();
        if (!isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        */
        this.fullDate = date;
    }

    /**
     * Returns true if a given string is a valid date.
     */
    public static boolean isValidDate(String test) {
        return test.matches(DATE_VALIDATION_REGEX);
    }
    
    public java.util.Date toDate() throws ParseException {
    	DateFormat df = new SimpleDateFormat("dd-MM-yyyy");
    	return df.parse(fullDate);
    }


    @Override
    public String toString() {
        return fullDate;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Date // instanceof handles nulls
                && this.fullDate.equals(((Date) other).fullDate)); // state check
    }

    @Override
    public int hashCode() {
        return fullDate.hashCode();
    }

}
```
###### \java\seedu\unburden\model\task\Name.java
``` java
 */


public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS = "Task names should be spaces or alphanumeric characters";
    public static final String NAME_VALIDATION_REGEX = "[\\p{Alnum} ]+";

    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        name = name.trim();
        if (!isValidName(name)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = name;
    }

    /**
     * Returns true if a given string is a valid person name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }
    
    public boolean contains (Set<String> args){
    	for(String name : args){
    		if(fullName.toLowerCase().contains(name.toLowerCase())){
    			return true;
    		}
    	}
    	return false;
    }

    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
```
###### \java\seedu\unburden\model\task\ReadOnlyTask.java
``` java
 */

//@@Gauri Joshi A0143095H
public interface ReadOnlyTask {

    Name getName();
    TaskDescription getTaskDescription();
    Date getDate();
    Time getStartTime();
    Time getEndTime();
    boolean getDone();
    String getDoneString();
    
    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the person's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && other.getName().equals(this.getName())); // state checks here onwards
    }

    /**
     * Formats the person as text, showing all contact details.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        
        if(getDate().fullDate == "NIL" && getStartTime().fullTime == "NIL" && getEndTime().fullTime == "NIL"){
        	builder.append(getName());
        	getTags().forEach(builder::append);
        }
        
        else if(getDate().fullDate != "NIL" && getStartTime().fullTime == "NIL" && getEndTime().fullTime == "NIL"){
        	builder.append(getName());
            builder.append("   Deadline : ");        
            builder.append(getDate());
            getTags().forEach(builder::append);
        }
        
        else if(getTaskDescription().fullTaskDescriptions != "NIL" && getDate().fullDate != "NIL" && getStartTime().fullTime != "NIL" && getEndTime().fullTime != "NIL"){       
	        builder.append(getName());
	        builder.append("   Task Description : ");        
	        builder.append(getTaskDescription());
	        builder.append("   Deadline : ");        
	        builder.append(getDate());
	        builder.append("   Start Time - End time : ");  
	        builder.append(getStartTime() + " - ");
	        builder.append(getEndTime() + "   ");
	        getTags().forEach(builder::append);
        }
        
        
        else {       
	        builder.append(getName());
	        builder.append("   Deadline : ");        
	        builder.append(getDate());
	        builder.append("   Start Time - End time : ");  
	        builder.append(getStartTime() + " - ");
	        builder.append(getEndTime() + "   ");
	        getTags().forEach(builder::append);
        }
        
        return builder.toString();
    }

    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }
	

}
```
###### \java\seedu\unburden\model\task\Task.java
``` java
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private TaskDescription taskD;
    private Date date;
    private Time startTime;
    private Time endTime;
    private UniqueTagList tags;
    private boolean done;
    private String getDoneString;

    /**
     * Every field must be present and not null.
     */
   
    //@@Nathanael Chan A0139678J
    // adds event
    public Task(Name name, TaskDescription taskD, Date date, Time startTime, Time endTime, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, taskD, date, startTime, endTime, tags);
        this.name = name;
        this.taskD = taskD;
        this.date = date;
        this.startTime = startTime;
        this.endTime = endTime;
        //this.getDoneString = getDoneString;
        this.tags = tags; // protect internal tags from changes in the arg list
    }
    
    // adds event without description 
    public Task(Name name,Date date, Time startTime, Time endTime, UniqueTagList tags) throws IllegalValueException {
        assert !CollectionUtil.isAnyNull(name, date, startTime, endTime, tags);
        this.name = name;
        this.taskD = new TaskDescription("NIL");
        this.date = date;
        this.startTime = startTime;
        this.endTime = endTime;
        this.tags = tags; // protect internal tags from changes in the arg list
    }
    
    // adds deadline
    public Task(Name name, TaskDescription taskD, Date date, Time endTime, UniqueTagList tags) throws IllegalValueException {
		assert!CollectionUtil.isAnyNull(name, taskD, date, endTime, tags);
		this.name = name;
		this.taskD = taskD;
		this.date = date;
		this.startTime = new Time("NIL");
		this.endTime = endTime;
		this.tags = tags;
	}
    
    // adds deadline without task description
    public Task(Name name, Date date, Time endTime, UniqueTagList tags) throws IllegalValueException {
		assert!CollectionUtil.isAnyNull(name, date, endTime, tags);
		this.name = name;
		this.taskD = new TaskDescription("NIL");
		this.date = date;
		this.startTime = new Time("NIL");
		this.endTime = endTime;
		this.tags = tags;
	}
    
    // adds deadline without task description and time
    public Task(Name name, Date date, UniqueTagList tags) throws IllegalValueException {
		assert!CollectionUtil.isAnyNull(name, date, tags);
		this.name = name;
		this.taskD = new TaskDescription("NIL");
		this.date = date;
		this.startTime = new Time("NIL");
		this.endTime = new Time("NIL");
		this.tags = tags;
	}
    
    // adds deadline without task description and date
    public Task(Name name, Time endTime, UniqueTagList tags) throws IllegalValueException {
		assert!CollectionUtil.isAnyNull(name, endTime, tags);
		this.name = name;
		this.taskD = new TaskDescription("NIL");
		this.date = new Date("NIL");
		this.startTime = new Time("NIL");
		this.endTime = endTime;
		this.tags = tags;
	}
    
    // adds deadline without date
    public Task(Name name, TaskDescription taskD, Time endTime, UniqueTagList tags) throws IllegalValueException {
		assert!CollectionUtil.isAnyNull(name, taskD, endTime, tags);
		this.name = name;
		this.taskD = taskD;
		this.date = new Date("NIL");
		this.startTime = new Time("NIL");
		this.endTime = endTime;
		this.tags = tags;
	}
    // adds deadline without time
    public Task(Name name, TaskDescription taskD, Date date, UniqueTagList tags) throws IllegalValueException {
		assert!CollectionUtil.isAnyNull(name, taskD, date, tags);
		this.name = name;
		this.taskD = taskD;
		this.date = date;
		this.startTime = new Time("NIL");
		this.endTime = new Time ("NIL");
		this.tags = tags;
	}
    
    // adds floating Task 
    public Task(Name name, TaskDescription taskD, UniqueTagList tags) throws IllegalValueException {
		assert !CollectionUtil.isAnyNull(name, taskD, tags);
		this.name = name;
		this.taskD = taskD;
		this.date = new Date("NIL");
		this.startTime = new Time("NIL");
		this.endTime = new Time("NIL");
		this.tags = tags;
	}

    // adds floating task without task description
	public Task(Name name, UniqueTagList tags) throws IllegalValueException {
		assert!CollectionUtil.isAnyNull(name, tags);
		this.name = name;
		this.taskD = new TaskDescription("NIL");
		this.date = new Date("NIL");
		this.startTime = new Time("NIL");
		this.endTime = new Time("NIL");
		this.tags = tags;
	}
	//@@Nathanael Chan
	
	/**
     * Copy constructor.
     */
	
	//@@Gauri Joshi A0143095H
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getTaskDescription(), source.getDate(), source.getStartTime(), source.getEndTime(), source.getTags());
    }

	@Override
    public Name getName() {
        return name;
    }
	
	@Override
    public TaskDescription getTaskDescription() {
        return taskD;
    }
    
    @Override
    public Date getDate() {
        return date;
    }
    
    @Override
    public Time getStartTime() {
        return startTime;
    }
    
    @Override
    public Time getEndTime() {
        return endTime;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }
    
    //@@Gauri Joshi A0143095H
	@Override
	public boolean getDone() {
		return done;
	}
	
	public String getDoneString(){
		if(done){
			getDoneString = "Done!";
		}
		else {
			getDoneString = "Undone!";
		}
		return getDoneString;
	}
    //@@Gauri Joshi A0143095H
    /**
     * Replaces this person's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }
    
    public void setName(Name name) {
        this.name = name;
    }
    
    public void setTaskDescription(TaskDescription taskD) {
        this.taskD = taskD;
    }
    
    public void setDate(Date date) {
        this.date = date;
    }
    
    public void setStartTime(Time startTime) {
        this.startTime = startTime;
    }
    
    public void setEndTime(Time endTime) {
        this.endTime = endTime;
    }
    
    public void setDone(boolean done) {
        this.done = done;
    }
    
    public boolean done(){
    	return false;
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    
        @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(name,taskD,date,startTime,endTime, tags);
    }
    //@@Gauri Joshi 


    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### \java\seedu\unburden\model\task\TaskDescription.java
``` java
 */

//@@Gauri Joshi A0143095H
public class TaskDescription {
	private static final String MESSAGE_TASK_CONSTRAINTS = "Task descriptions should be spaces or alphanumeric characters.";
	public static final String TASK_VALIDATION_REGEX = "[\\p{Alnum} ]+";
	
	public final String fullTaskDescriptions;

	/**
	 * 
	 * @param details
	 *            Validates the given String as a task description
	 * @throws IllegalValueException
	 *             if the string passed in is invalid
	 */
	public TaskDescription(String details) throws IllegalValueException {
		/*
		assert details != null;
		details = details.trim();
		if (isValidDetails(details)) {
			throw new IllegalValueException(MESSAGE_TASK_CONSTRAINTS);
		}
		*/
		this.fullTaskDescriptions = details;
	}

	private boolean isValidDetails(String details) {
		return details.matches(TASK_VALIDATION_REGEX);
	}

	@Override
	public String toString() {
		return fullTaskDescriptions;
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
				|| (other instanceof TaskDescription // instanceof handles nulls
						&& this.fullTaskDescriptions.equals(((TaskDescription) other).fullTaskDescriptions)); 
	}

	@Override
	public int hashCode() {
		return fullTaskDescriptions.hashCode();
	}

}
```
###### \java\seedu\unburden\model\task\Time.java
``` java
 */

//@@ Gauri Joshi A0143095H
public class Time {

    public static final String MESSAGE_TIME_CONSTRAINTS = "Task time should be in the format XXYY where X represents the number of hours and Y represents the number of minutes";
    public static final String TIME_VALIDATION_REGEX = ".+";
    
    //\\[0-9]{2}[0-9]{2}

    public final String fullTime;

    /**
     * Validates given time.
     *
     * @throws IllegalValueException if given time string is invalid.
     */
    public Time(String time) throws IllegalValueException {
        assert time != null;
       // time = time.trim();
        /*if (!isValidTime(time)) {
            throw new IllegalValueException(MESSAGE_TIME_CONSTRAINTS);
        }
        */
        this.fullTime = time;
    }

    /**
     * Returns true if a given string is a valid time.
     */
    public static boolean isValidTime(String test) {
        return test.matches(TIME_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return fullTime;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Time // instanceof handles nulls
                && this.fullTime.equals(((Time) other).fullTime)); // state check
    }

    @Override
    public int hashCode() {
        return fullTime.hashCode();
    }

}
```
###### \java\seedu\unburden\ui\BrowserPanel.java
``` java
 */
public class BrowserPanel extends UiPart{

    private static Logger logger = LogsCenter.getLogger(BrowserPanel.class);
    private WebView browser;

    /**
     * Constructor is kept private as {@link #load(AnchorPane)} is the only way to create a BrowserPanel.
     */
    private BrowserPanel() {

    }

    @Override
    public void setNode(Node node) {
        //not applicable
    }

    @Override
    public String getFxmlPath() {
        return null; //not applicable
    }

    /**
     * Factory method for creating a Browser Panel.
     * This method should be called after the FX runtime is initialized and in FX application thread.
     * @param placeholder The AnchorPane where the BrowserPanel must be inserted
     */
    public static BrowserPanel load(AnchorPane placeholder){
        logger.info("Initializing browser");
        BrowserPanel browserPanel = new BrowserPanel();
        browserPanel.browser = new WebView();
        placeholder.setOnKeyPressed(Event::consume); // To prevent triggering events for typing inside the loaded Web page.
        FxViewUtil.applyAnchorBoundaryParameters(browserPanel.browser, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(browserPanel.browser);
        return browserPanel;
    }

    public void loadPersonPage(ReadOnlyTask person) {
        loadPage("https://www.google.com.sg/#safe=off&q=" + person.getName().fullName.replaceAll(" ", "+"));
    }

    public void loadPage(String url){
        browser.getEngine().load(url);
    }

    /**
     * Frees resources allocated to the browser.
     */
    public void freeResources() {
        browser = null;
    }

}
```
###### \java\seedu\unburden\ui\CommandBox.java
``` java
public class CommandBox extends UiPart {
    private final Logger logger = LogsCenter.getLogger(CommandBox.class);
    private static final String FXML = "CommandBox.fxml";

    private AnchorPane placeHolderPane;
    private AnchorPane commandPane;
    private ResultDisplay resultDisplay;
    String previousCommandTest;

    private Logic logic;

    @FXML
    private TextField commandTextField;
    private CommandResult mostRecentResult;

    public static CommandBox load(Stage primaryStage, AnchorPane commandBoxPlaceholder,
            ResultDisplay resultDisplay, Logic logic) {
        CommandBox commandBox = UiPartLoader.loadUiPart(primaryStage, commandBoxPlaceholder, new CommandBox());
        commandBox.configure(resultDisplay, logic);
        commandBox.addToPlaceholder();
        return commandBox;
    }

    public void configure(ResultDisplay resultDisplay, Logic logic) {
        this.resultDisplay = resultDisplay;
        this.logic = logic;
        registerAsAnEventHandler(this);
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(commandTextField);
        FxViewUtil.applyAnchorBoundaryParameters(commandPane, 0.0, 0.0, 0.0, 0.0);
        FxViewUtil.applyAnchorBoundaryParameters(commandTextField, 0.0, 0.0, 0.0, 0.0);
    }

    @Override
    public void setNode(Node node) {
        commandPane = (AnchorPane) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }


    @FXML
    private void handleCommandInputChanged() throws ParseException {
        //Take a copy of the command text
        previousCommandTest = commandTextField.getText();

        /* We assume the command is correct. If it is incorrect, the command box will be changed accordingly
         * in the event handling code {@link #handleIncorrectCommandAttempted}
         */
        setStyleToIndicateCorrectCommand();
        mostRecentResult = logic.execute(previousCommandTest);
        resultDisplay.postMessage(mostRecentResult.feedbackToUser);
        logger.info("Result: " + mostRecentResult.feedbackToUser);
    }


    /**
     * Sets the command box style to indicate a correct command.
     */
    private void setStyleToIndicateCorrectCommand() {
        commandTextField.getStyleClass().remove("error");
        commandTextField.setText("");
    }

    @Subscribe
    private void handleIncorrectCommandAttempted(IncorrectCommandAttemptedEvent event){
        logger.info(LogsCenter.getEventHandlingLogMessage(event,"Invalid command: " + previousCommandTest));
        setStyleToIndicateIncorrectCommand();
        restoreCommandText();
    }

    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandTest);
    }

    /**
     * Sets the command box style to indicate an error
     */
    private void setStyleToIndicateIncorrectCommand() {
        commandTextField.getStyleClass().add("error");
    }

}
```
###### \java\seedu\unburden\ui\MainWindow.java
``` java
 */
public class MainWindow extends UiPart {

    private static final String ICON = "/images/Unburden3_logo.JPG";
    private static final String FXML = "MainWindow.fxml";
    public static final int MIN_HEIGHT = 600;
    public static final int MIN_WIDTH = 450;

    private Logic logic;

    // Independent Ui parts residing in this Ui container
    private BrowserPanel browserPanel;
    private TaskListPanel taskListPanel;
    private ResultDisplay resultDisplay;
    private StatusBarFooter statusBarFooter;
    private CommandBox commandBox;
    private Config config;
    private UserPrefs userPrefs;

    // Handles to elements of this Ui container
    private VBox rootLayout;
    private Scene scene;

    private String addressBookName;

    @FXML
    private AnchorPane browserPlaceholder;

    @FXML
    private AnchorPane commandBoxPlaceholder;

    @FXML
    private MenuItem helpMenuItem;

    @FXML
    private AnchorPane personListPanelPlaceholder;

    @FXML
    private AnchorPane resultDisplayPlaceholder;

    @FXML
    private AnchorPane statusbarPlaceholder;


    public MainWindow() {
        super();
    }

    @Override
    public void setNode(Node node) {
        rootLayout = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public static MainWindow load(Stage primaryStage, Config config, UserPrefs prefs, Logic logic) {

        MainWindow mainWindow = UiPartLoader.loadUiPart(primaryStage, new MainWindow());
        mainWindow.configure(config.getAppTitle(), config.getTaskListName(), config, prefs, logic);
        return mainWindow;
    }

    private void configure(String appTitle, String addressBookName, Config config, UserPrefs prefs,
                           Logic logic) {

        //Set dependencies
        this.logic = logic;
        this.addressBookName = addressBookName;
        this.config = config;
        this.userPrefs = prefs;

        //Configure the UI
        setTitle(appTitle);
        setIcon(ICON);
        setWindowMinSize();
        setWindowDefaultSize(prefs);
        scene = new Scene(rootLayout);
        primaryStage.setScene(scene);

        setAccelerators();
    }

    private void setAccelerators() {
        helpMenuItem.setAccelerator(KeyCombination.valueOf("F1"));
    }

    void fillInnerParts() {
        browserPanel = BrowserPanel.load(browserPlaceholder);
        taskListPanel = TaskListPanel.load(primaryStage, getPersonListPlaceholder(), logic.getFilteredTaskList());
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getTaskListFilePath());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }

    private AnchorPane getCommandBoxPlaceholder() {
        return commandBoxPlaceholder;
    }

    private AnchorPane getStatusbarPlaceholder() {
        return statusbarPlaceholder;
    }

    private AnchorPane getResultDisplayPlaceholder() {
        return resultDisplayPlaceholder;
    }

    public AnchorPane getPersonListPlaceholder() {
        return personListPanelPlaceholder;
    }

    public void hide() {
        primaryStage.hide();
    }

    private void setTitle(String appTitle) {
        primaryStage.setTitle(appTitle);
    }

    /**
     * Sets the default size based on user preferences.
     */
    protected void setWindowDefaultSize(UserPrefs prefs) {
        primaryStage.setHeight(prefs.getGuiSettings().getWindowHeight());
        primaryStage.setWidth(prefs.getGuiSettings().getWindowWidth());
        if (prefs.getGuiSettings().getWindowCoordinates() != null) {
            primaryStage.setX(prefs.getGuiSettings().getWindowCoordinates().getX());
            primaryStage.setY(prefs.getGuiSettings().getWindowCoordinates().getY());
        }
    }

    private void setWindowMinSize() {
        primaryStage.setMinHeight(MIN_HEIGHT);
        primaryStage.setMinWidth(MIN_WIDTH);
    }

    /**
     * Returns the current size and the position of the main Window.
     */
    public GuiSettings getCurrentGuiSetting() {
        return new GuiSettings(primaryStage.getWidth(), primaryStage.getHeight(),
                (int) primaryStage.getX(), (int) primaryStage.getY());
    }

    @FXML
    public void handleHelp() {
        HelpWindow helpWindow = HelpWindow.load(primaryStage);
        helpWindow.show();
    }

    public void show() {
        primaryStage.show();
    }

    /**
     * Closes the application.
     */
    @FXML
    private void handleExit() {
        raise(new ExitAppRequestEvent());
    }

    public TaskListPanel getPersonListPanel() {
        return this.taskListPanel;
    }

    public void loadPersonPage(ReadOnlyTask person) {
        browserPanel.loadPersonPage(person);
    }

    public void releaseResources() {
        browserPanel.freeResources();
    }
}
```
###### \java\seedu\unburden\ui\ResultDisplay.java
``` java
 */
public class ResultDisplay extends UiPart {
    public static final String RESULT_DISPLAY_ID = "resultDisplay";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    private TextArea resultDisplayArea;
    private final StringProperty displayed = new SimpleStringProperty("");

    private static final String FXML = "ResultDisplay.fxml";

    private AnchorPane placeHolder;

    private AnchorPane mainPane;

    public static ResultDisplay load(Stage primaryStage, AnchorPane placeHolder) {
        ResultDisplay statusBar = UiPartLoader.loadUiPart(primaryStage, placeHolder, new ResultDisplay());
        statusBar.configure();
        return statusBar;
    }

    public void configure() {
        resultDisplayArea = new TextArea();
        resultDisplayArea.setEditable(false);
        resultDisplayArea.setId(RESULT_DISPLAY_ID);
        resultDisplayArea.getStyleClass().removeAll();
        resultDisplayArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        resultDisplayArea.setText("");
        resultDisplayArea.textProperty().bind(displayed);
        FxViewUtil.applyAnchorBoundaryParameters(resultDisplayArea, 0.0, 0.0, 0.0, 0.0);
        mainPane.getChildren().add(resultDisplayArea);
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (AnchorPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    public void postMessage(String message) {
        displayed.setValue(message);
    }

}
```
###### \java\seedu\unburden\ui\StatusBarFooter.java
``` java
 */
public class StatusBarFooter extends UiPart {
    private static final Logger logger = LogsCenter.getLogger(StatusBarFooter.class);
    private StatusBar syncStatus;
    private StatusBar saveLocationStatus;

    private GridPane mainPane;

    @FXML
    private AnchorPane saveLocStatusBarPane;

    @FXML
    private AnchorPane syncStatusBarPane;

    private AnchorPane placeHolder;

    private static final String FXML = "StatusBarFooter.fxml";

    public static StatusBarFooter load(Stage stage, AnchorPane placeHolder, String saveLocation) {
        StatusBarFooter statusBarFooter = UiPartLoader.loadUiPart(stage, placeHolder, new StatusBarFooter());
        statusBarFooter.configure(saveLocation);
        return statusBarFooter;
    }

    public void configure(String saveLocation) {
        addMainPane();
        addSyncStatus();
        setSyncStatus("Not updated yet in this session");
        addSaveLocation();
        setSaveLocation("./" + saveLocation);
        registerAsAnEventHandler(this);
    }

    private void addMainPane() {
        FxViewUtil.applyAnchorBoundaryParameters(mainPane, 0.0, 0.0, 0.0, 0.0);
        placeHolder.getChildren().add(mainPane);
    }

    private void setSaveLocation(String location) {
        this.saveLocationStatus.setText(location);
    }

    private void addSaveLocation() {
        this.saveLocationStatus = new StatusBar();
        FxViewUtil.applyAnchorBoundaryParameters(saveLocationStatus, 0.0, 0.0, 0.0, 0.0);
        saveLocStatusBarPane.getChildren().add(saveLocationStatus);
    }

    private void setSyncStatus(String status) {
        this.syncStatus.setText(status);
    }

    private void addSyncStatus() {
        this.syncStatus = new StatusBar();
        FxViewUtil.applyAnchorBoundaryParameters(syncStatus, 0.0, 0.0, 0.0, 0.0);
        syncStatusBarPane.getChildren().add(syncStatus);
    }

    @Override
    public void setNode(Node node) {
        mainPane = (GridPane) node;
    }

    @Override
    public void setPlaceholder(AnchorPane placeholder) {
        this.placeHolder = placeholder;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }
    
    //@@Gary Goh A0139714B
    @Subscribe
    public void handleListOfTaskChangedEvent(ListOfTaskChangedEvent abce) {
        String lastUpdated = (new Date()).toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(abce, "Setting last updated status to " + lastUpdated));
        setSyncStatus("Last Updated: " + lastUpdated);
    }
    //@@Gary Goh 
    
    @Subscribe
    public void handleStoragePathChangeEvent(StoragePathChangedEvent event) {
    	try {
	    	String configFilePathUsed = Config.DEFAULT_CONFIG_FILE;
	        Config config = ConfigUtil.readConfig(configFilePathUsed).orElse(new Config());
	        setSaveLocation(config.getTaskListFilePath());
	    } catch (DataConversionException e) {
	        logger.warning("Error retrieving data from " + Config.DEFAULT_CONFIG_FILE + ". "
	                + "Using default config properties");
	        Config config = new Config();
	        setSaveLocation(config.getTaskListFilePath());
	    }
    }
}
```
###### \java\seedu\unburden\ui\TaskListPanel.java
``` java
 */
public class TaskListPanel extends UiPart {
    private final Logger logger = LogsCenter.getLogger(TaskListPanel.class);
    private static final String FXML = "TaskListPanel.fxml";
    private VBox panel;
    private AnchorPane placeHolderPane;

    @FXML
    private ListView<ReadOnlyTask> taskListView;

    public TaskListPanel() {
        super();
    }

    @Override
    public void setNode(Node node) {
        panel = (VBox) node;
    }

    @Override
    public String getFxmlPath() {
        return FXML;
    }

    @Override
    public void setPlaceholder(AnchorPane pane) {
        this.placeHolderPane = pane;
    }

    public static TaskListPanel load(Stage primaryStage, AnchorPane taskListPlaceholder,
                                       ObservableList<ReadOnlyTask> taskList) {
        TaskListPanel taskListPanel =
                UiPartLoader.loadUiPart(primaryStage, taskListPlaceholder, new TaskListPanel());
        taskListPanel.configure(taskList);
        return taskListPanel;
    }

    private void configure(ObservableList<ReadOnlyTask> taskList) {
        setConnections(taskList);
        addToPlaceholder();
    }

    private void setConnections(ObservableList<ReadOnlyTask> taskList) {
        taskListView.setItems(taskList);
        taskListView.setCellFactory(listView -> new TaskListViewCell());
        setEventHandlerForSelectionChangeEvent();
    }

    private void addToPlaceholder() {
        SplitPane.setResizableWithParent(placeHolderPane, false);
        placeHolderPane.getChildren().add(panel);
    }

    private void setEventHandlerForSelectionChangeEvent() {
        taskListView.getSelectionModel().selectedItemProperty().addListener((observable, oldValue, newValue) -> {
            if (newValue != null) {
                logger.fine("Selection in task list panel changed to : '" + newValue + "'");
                raise(new TaskPanelSelectionChangedEvent(newValue));
            }
        });
    }

    public void scrollTo(int index) {
        Platform.runLater(() -> {
            taskListView.scrollTo(index);
            taskListView.getSelectionModel().clearAndSelect(index);
        });
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        public TaskListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null) {
                setGraphic(null);
                setText(null);
            } else {
                setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
            }
        }
    }

}
```
